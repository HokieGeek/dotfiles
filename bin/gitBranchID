#!/bin/bash

# Make use of the native enchanced echo, if it exists
RED=""
GREEN=""
YELLOW=""
BLUE=""
PURPLE=""
CYAN=""
GRAY=""
BRIGHT=""
ALLOFF=""

if [ "`\echo -e`" != "-e" ]; then
    RED="\033[31m"
    GREEN="\033[32m"
    YELLOW="\033[33m"
    BLUE="\033[34m"
    PURPLE="\033[35m"
    CYAN="\033[36m"
    GRAY="\033[37m"
    BRIGHT="\033[1m"
    ALLOFF="\033[0m"
    #alias echo='\echo -e'
    ECHO='echo -e'
fi

if [ "$1" = "-help" -o "$1" = "-h" ]; then
    {
    echo "        Script Name: `basename $0`" 
    echo ""
    echo "        Syntax:      `basename $0` [-help|-h] [server]"
    echo ""
more << USAGE_INFO
      Description: Allows you to perform a pull from any repository
                 from any branch. It employs two paths for determining which 
    
    Options:     -help -h 

    Arguments:   server         - location or git alias to server location 
                 branch         - remote branch to pull from 

             Default behavior for determining the server and branch is to retrieve 
             the information from the currently checked out branch. If the branch is 
             only available locally or if there are multiple remote servers which 
             contain that branch, then it will ask for user input on how to proceed.

             The arguments will override the default behavior.
USAGE_INFO
    } >&2
  exit 0
fi

# if [  -e ~/.gitCurrentUpdate  ]; then
  # mv -f ~/.gitCurrentUpdate ~/.gitLastUpdate
# else
  # echo `date +%F` > ~/.gitLastUpdate
# fi
# echo `date +%F` > ~/.gitCurrentUpdate

if [ $# -gt 0 -a $# -lt 1  ]; then
  echo "Error: Invalid number of arguments"
  exec $0 -help
fi

EXIT_NORMAL=0
EXIT_SKIPPED=1
EXIT_ERROR=2
EXIT_ERROR_NO_REMOTE=3
EXIT_CONFLICT=4
self_status=$EXIT_NORMAL

out="/tmp/gitBranchID_out.$$"
tmpout="/tmp/gitBranchID_tmp.$$"
server=$1
branch=""
real_branch=""

#echo "DEBUG: HERE"
# CD into the directory and update the remotes
[ $? -ne 0 ] && self_status=$EXIT_ERROR
m=`pwd`

# Determine the server and branch
if [ "$branch" = '' -a $self_status -le 0 ]; then # Retrieve the currently selected branch
    branch=`git branch -a | egrep "^\*" | sed -e "s/\*\s*//"`
fi

# Retrieve the matching remote names where the branch is located
declare -a server=`git branch -a | grep "remotes" | grep -v "\->" | grep "${branch}" | sed -e 's;^\s*remotes/;;' -e "s;/${branch};;"`

if [ "${server}" = ""  ]; then # If no remotes are found, ask if should pull from origin/master
    ${ECHO} "Branch '$branch' was not found on any of the remote servers."
    ${ECHO} -n "${BRIGHT}Rebase from origin/master? (y/n): ${ALLOFF}"
    read dummy
    #TODO: What if origin/master doesn't exist?
    #if [  $< == 'y'  ]; then
    if [ "$dummy" == 'y'  ]; then
        real_branch=${branch}
        server="origin"
        branch="master"
    else
        self_status=$EXIT_ERROR_NO_REMOTE
    fi
    echo ""
elif [ ${#server[@]} -gt 1  ]; then # If there are multiple remote names with this branch name, ask the user to select one
    servers=(${server})
    server=""
    echo "Found branch '$branch' in multiple remote repositories. Choose one:"
    while [ "${server}" == "" -a $self_status -le 0 ]; do
        i=1
        for s in $servers; do
        #foreach s ($servers)
            # set r=`git remote -v | grep "fetch" | grep "${s}" | sed 's/\s*(fetch)$//'`
            r=`git remote -v | grep "fetch" | grep "${s}" | awk '{ print $2 }'`
            echo "${i}: $s   ($r)"
            i=`expr $i + 1`
        done
        echo "0: SKIP THIS MODULE"
        ${ECHO} -n "${BRIGHT}Choose: ${ALLOFF}"
        read choice
        # set choice=$<
        if [ $choice -eq 0 ]; then
            self_status=$EXIT_SKIPPED
        elif [ $choice -lt 0 -o $choice -gt ${#servers} ]; then
            ${ECHO} "${RED}ERROR: Invalid choice '$choice'. Please choose again${ALLOFF}"
        else
            server=${servers[$choice]}
        fi
    done
    echo ""
fi

if [ $self_status -le 0 ]; then
    echo -n "${server}:${branch}"
    if [ "$?real_branch" != "" ]; then
        echo -n "|${real_branch}"
    fi
    echo ""
fi

exit $self_status
