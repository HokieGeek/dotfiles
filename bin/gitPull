#!/bin/sh

# Make use of the native enchanced echo, if it exists
RED=""
GREEN=""
YELLOW=""
BLUE=""
PURPLE=""
CYAN=""
GRAY=""
BRIGHT=""
ALLOFF=""
ECHO='echo'

if [ "`\echo -e`" != "-e" ]; then
    RED="\033[31m"
    GREEN="\033[32m"
    YELLOW="\033[33m"
    BLUE="\033[34m"
    PURPLE="\033[35m"
    CYAN="\033[36m"
    GRAY="\033[37m"
    BRIGHT="\033[1m"
    ALLOFF="\033[0m"
    #alias echo='\echo -e'
    ECHO='echo -e'
fi
if [ $# -gt 0 ]; then
    echo "HERE"
    exit 42
fi

if [ $# -gt 0 ]; then
    if [ "$1" = "-help" -o "$1" = "-h" ]; then
        {
        echo "        Script Name: `basename $0`"
        echo ""
        echo "        Syntax:      `basename $0` [-help|-h] [server] [branch]"
        echo ""
    more << USAGE_INFO
          Description: Allows you to perform a pull from any repository
                     from any branch. It employs two paths for determining which

        Options:     -help -h

        Arguments:   server         - location or git alias to server location
                     branch         - remote branch to pull from

                 Default behavior for determining the server and branch is to retrieve
                 the information from the currently checked out branch. If the branch is
                 only available locally or if there are multiple remote servers which
                 contain that branch, then it will ask for user input on how to proceed.

                 The arguments will override the default behavior.
USAGE_INFO
        } >&2
      exit 0
    fi
fi

# if [  -e ~/.gitCurrentUpdate  ]; then
  # mv -f ~/.gitCurrentUpdate ~/.gitLastUpdate
# else
  # echo `date +%F` > ~/.gitLastUpdate
# fi
# echo `date +%F` > ~/.gitCurrentUpdate

if [ $# -gt 0 -a $# -lt 2 ]; then
  echo "Error: Invalid number of arguments"
  exec $0 -help
fi

EXIT_NORMAL=0
EXIT_SKIPPED=1
EXIT_ERROR=2
EXIT_ERROR_NO_REMOTE=3
EXIT_CONFLICT=4
self_status=$EXIT_NORMAL
DEBUG_ON=true

out="/tmp/gitPull_out.$$"
tmpout="/tmp/gitPull_tmp.$$"
server=$1
branch=$2
no_remote_branch=""

conflictPat="(CONFLICT|merge)"
m=`pwd`

# CD into the directory and update the remotes
$DEBUG_ON && ${ECHO} "DEBUG: remote update"
git remote update --prune | tee ${tmpout}
[ $? -ne 0 ] && self_status=$EXIT_ERROR

#${ECHO} "DEBUG: server_branch"
if [ "$branch" = '' -o "$server" = '' ]; then
    $DEBUG_ON && ${ECHO} "DEBUG: calling 'gitBranchID $server'"
    #
    gbid_log=/tmp/gitBranchID.$$
    $HOME/.bin/gitBranchID ${server} &> $gbid_log
    branch_id_status=$?
    server_branch=`tail -1 $gbid_log`
    rm -rf $gbid_log

    if [ $branch_id_status -eq $EXIT_SKIPPED ]; then
        self_status=$EXIT_SKIPPED
    elif [ $branch_id_status -eq $EXIT_ERROR_NO_REMOTE ]; then
        self_status=$EXIT_ERROR
    else
        server=`echo $server_branch | cut -d'|' -f1 | cut -d':' -f1`
        branch=`echo $server_branch | cut -d'|' -f1 | cut -d':' -f2`
        no_remote_branch=`echo $server_branch | cut -d'|' -f2`
    fi
fi

$DEBUG_ON && ${ECHO} "DEBUG: self_status"
if [ $self_status -le 0 ]; then
    # Perform the update
    ${ECHO} "${CYAN}Updating from ${server}/${branch}${ALLOFF}"

    stashed_changes=""
    if [ "$no_remote_branch" != "" ]; then
        stashed_changes=${no_remote_branch}
        git stash save "gitPull_${no_remote_branch}"
        git checkout master
    elif [ `git status | grep -c 'working directory clean'` -le 0 ]; then
        stashed_changes=${branch}
        git stash save "gitPull_${branch}"
    fi

    # git pull --verbose --tags $server $branch |& tee ${tmpout}
    git fetch --tags --verbose ${server} 2>&1 | tee ${tmpout}

    ## TODO: if we have no remote, we need to go back to our branch now
    ##       and rebase master in
    if [ "$no_remote_branch" != "" ]; then
        git rebase ${server}/master 2>&1 | tee ${tmpout}
        git checkout $no_remote_branch
        git rebase master 2>&1 | tee ${tmpout}
    else
        git rebase ${server}/${branch} 2>&1 | tee ${tmpout}
    fi

    if [ "$stashed_changes" != "" ]; then
        if [ `git stash list | head -1 | cut -d: -f3 | grep -c "gitPull_${stashed_changes}"` -ge 1 ];  then
            stash_pos=`git stash list | grep gitPull_${stashed_changes} | cut -d: -f1 | sed 's/stash@{\([0-9]*\)}/\1/g'`
            git stash pop "stash@{${stash_pos}}"
        fi
    fi

    # Determine if there were any issues. Append to file to output at end
    conflictCheck=`egrep -c "$conflictPat" ${tmpout}`
    if [ $conflictCheck -gt 0 ]; then
        self_status=$EXIT_CONFLICT
        # awk_cmd="{ print "'"'"${BRIGHT}${RED}ERROR: ${name}: '"'"$0"'"'${ALLOFF}"'"'" }"
        # egrep $conflictPat ${tmpout} | egrep "^error:" | awk "$awk_cmd" >> ${out}
        # egrep $conflictPat ${tmpout} | awk "$awk_cmd" >> ${out}
    fi
fi

# Cleanup
[ -f ${tmpout} ] && rm -rf ${out} ${tmpout}

exit ${self_status}
