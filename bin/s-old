#!/bin/bash

# TODO:
#   - Having to wait for the io buffer to catch up is really becoming a problem
#   - Implement a "quick" option which skips writing to file (formatted without line nums)
#   - Allow for filenames for default command
#   - Maybe implement paging (h/l)
#   - Might want to consider nav (j/k) along with paging

usage() {
    {
    [ $# -gt 0 ] && echo -e "${1}\n"
    echo "USAGE: `basename $0` [-g|-a|-f] [-i] <EXPRESSION>"
    # echo "USAGE: `basename $0` [-g|-a|-f] <EXPRESSION> [<FILENAMES>]"
    echo ""
    more << USAGE_INFO
       DEFAULT - Does a recursive, case-sensitive grep on
                all files matching file names, contents and archives
       -g      - Greps the contents of all of the files in the directory (recursive)
       -a      - Searches the content list of archives (tar,jar,zip) for matching paths
       -f      - Searches for file and directory names (recursive)

       -i      - Makes any search case-insensitive
USAGE_INFO
    } >&2
}

exit_cleanup() {
    ret=$?
    echo ""

    # Delete files
    rm -rf $results $status $ar_extract $vi_script

    # Kill the children
    # ([ ! -z $children ] && kill -9 $children) 2>&1 >/dev/null

    exit $ret
}
trap "exit_cleanup" EXIT HUP INT TERM

# Variables
MAX_RESULTS_TO_OPEN=30
RESULT_TYPE_GREP="g"
RESULT_TYPE_FILE="f"
RESULT_TYPE_ARCHIVE="a"
DELIM=":"
AR_ARCHIVEDELIM=">>>>>>"

inputMode="DEFAULT"
children=""
numResults=0
ar_lastfound=""
expression=""
searchType="UNIVERSAL"
caseInsensitive=0
CIOpt_grep=""
CIOpt_find=""
results=/tmp/searchResults.tmp.$$
status=/tmp/searchStatus.tmp.$$
ar_extract=/tmp/searchARExtract.tmp.$$
vi_script=/tmp/searchAllOpen.tmp.$$
log=/tmp/s_log

# Parse the arguments
while [ $# -gt 0 ]; do
    case $1 in
    -a) searchType="AR_CONTENTS";;
    -f) searchType="FILE_NAMES";;
    -g) searchType="GREP_ALL";;
    -i) caseInsensitive=1;;
    *) expression="${expression} $1";;
    esac
    shift
done

if [ $caseInsensitive -gt 0 ]; then
    CIOpt_grep="-i"
    CIOpt_find="i"
fi
expression=`echo $expression | sed -e 's/^\s\*//g' -e 's/\s\*$//g'` # Trim
if [ -z "${expression}" ]; then
    usage "No search expression provided"
    exit 1
fi

displayResults() {
    sleep 5
    numResults=`cat $results | wc -l`
    i=1
    # echo "$results ($numResults)" > /tmp/test
    # cat $results >> /tmp/test
    set -o noglob
    while read fl; do
        if [ "`echo $fl | cut -d' ' -f1`" == "Binary" ]; then
            numResults=`expr $numResults - 1`
            continue
        fi
        formatResult ${i} "${fl}" && i=`expr $i + 1`
    done < $results
    set +o noglob
}

formatResult() {
    ret=0
    pos=$1; shift
    fl=$*

    # Determine the result type
    resultType=`echo $fl | cut -d${DELIM} -f1`
    fl=`echo $fl | sed -e "s;^${resultType}${DELIM};;"`

    # Determine the color (cyan or gray)
    [ `expr ${pos} % 4` -eq 1 -a ${numResults} -gt 5 ] && c="36" || c="37"

    # Builds the sed expression that highlights the matched patterns
    exp=`echo ${expression} | sed -e 's;^(\(.*\))$;\1;g' -e 's;|;\\\\|;g'`
    sc_hlparam="s;\(${exp}\);\\\\E[31m\1\\\\E[${c}m;"`[ $caseInsensitive -gt 0 ] && echo "i"`

    # Format the line prior to printing
    is_ar_header=`echo $fl | grep -c "${AR_ARCHIVEDELIM}"`
    case ${resultType} in
    ${RESULT_TYPE_GREP})
        # Retrieve the file path and make the filename brighter than the rest
        f=`echo $fl | cut -d${DELIM} -f1`
        name=`basename $f`
        [ "`dirname $f`" != "." ] && f2="`dirname $f`/" || f2=""
        f2="${f2}\E[1m${name}\E[0m\E[${c}m"

        # Retrieve the position of the hit
        p=`echo $fl | cut -d${DELIM} -f2`

        # Retrieve the hit part of the line
        # and color the search parameter red
        h=`echo ${fl} | sed -e "s;^${f}${DELIM}${p}${DELIM};;" -e "${sc_hlparam}"` #TODO: change ;

        # Now rebuild the line
        l="${f2}${DELIM}${p} $h"
        ;;
    ${RESULT_TYPE_ARCHIVE}|${RESULT_TYPE_FILE})
        if [ ${is_ar_header} -gt 0 ]; then
            l=$fl
        else
            [ "${resultType}" == ${RESULT_TYPE_ARCHIVE} ] && fl=`echo $fl | sed "s;^.*${DELIM};;"`
            name=`echo $fl | awk -F'/' '{ print $NF }'`
            f=`echo $fl | sed -e "s;${name}\$;;"`"\E[1m${name}\E[0m\E[${c}m"
            [ "`dirname $f`" == "." ] && f="`echo $f | sed 's;^\./;;'`"
            l=`echo $f | sed -e "${sc_hlparam}"`
        fi
        ;;
    esac

    # Number the line if it's not an archive name
    if [ ${is_ar_header} -eq 0 ]; then
        [ ${#numResults} -gt 1 -a $pos -lt 10 ] && l="0${pos}. $l" || l="${pos}. $l"
    # else TODO: This breaks "opening"
        # ret=1
    fi

    # Now output the line with the appropriate color
    echo -e "\E[${c}m"${l}"\E[0m"

    return $ret
}

openResult() {
    # Retrieve the record
    r=`sed -n ${1}'p' ${results}`
    resultType=`echo $r | cut -d${DELIM} -f1`
    r=`echo $r | sed -e "s;^${resultType}${DELIM};;"`

    # Parse out the file name from the record
    case $searchType in
    GREP_ALL|FILE_NAMES)
        f=`echo $r | cut -d${DELIM} -f1`
        [ "$searchType" != "FILE_NAMES" ] && p=`echo $r | cut -d${DELIM} -f2`
        [ ! -f "$f" ] && return
        ;;
    AR_CONTENTS)
        ar=`echo $r | cut -d${DELIM} -f1`
        f=`echo $r | cut -d${DELIM} -f2`
        ;;
    esac

    # Determine which instance of vi to use	
    [ -x "`which vim 2>/dev/null`" ] && v=vim || v=vi

    # Open the file
    case ${searchType} in
    GREP_ALL)
        ${v} +${p} -c "set cursorline" -c "set number" -c "hi CursorLine ctermbg=red ctermfg=white cterm=none" $f
        ;;
    AR_CONTENTS)
        # Create the extract directory, navigate to it, and remember where we are
        curr=`pwd`
        [ ! -d "${ar_extract}" ] && mkdir -p "${ar_extract}"
        cd "${ar_extract}"
        ar=`echo $ar | sed 's;^\./;;'`

        doArAction "${curr}/${ar}" "EXTRACT" "${f}" 2>&1 >/dev/null
        sleep 0.125
        [ ! -f "${ar_extract}/${f}" ] && return
        $v "${ar_extract}/${f}"

        # Return us back to where we were
        cd "${curr}"
        ;;
    FILE_NAMES) ${v} ${f} ;;
    esac
}

openMultipleResults() {
    # Parse out all unique file names from the records
    range=""
    if [ $# -gt 0 ]; then
        range=`echo $* | tr ',' ' ' | tr '-' ',' | sed -e 's/\([0-9]\+\(,[0-9]\+\)\?\)/-e \1p/g'`
    else
        range="1,\$p"
    fi
    echo "RANGE: $range" >> $log
    files=""
    for r in `sed -n ${range} ${results}`; do
        f=`echo $r | sed -e "s/^[a-z]${DELIM}//" | cut -d${DELIM} -f1`
        [ ! -f "$f" ] && continue
        [ `echo $files | grep -c "${f}"` -gt 0 ] && continue
        files="$files $f"
    done

    # Build the script
    {
        echo $files | awk 'BEGIN { RS=" " } { print ":tabnew "$0 }'
        echo ":tabfirst"
        echo ":tabclose!"
        echo "/`echo ${expression} | sed 's;\([()|]\);\\\\&;g'`"
    } > $vi_script

    # Determine which instance of vi to use	and load the script
    [ -x "`which vim 2>/dev/null`" ] && v=vim || v=vi
    ${v} -s ${vi_script}
}

displayDefaultPrompt() {
    [ $# -gt 0 ] && format=${1} || format="\E[1m\E[32m"

    padding=""
    case ${#numResults} in
    2) padding="0";;
    3) padding="00";;
    4) padding="000";;
    5) padding="0000";;
    6) padding="00000";;
    esac
    range="${padding}1-${numResults},q"

    displayPrompt ${format} ${range} ">"
}

displayPrompt() {
    [ $# -lt 3 ] && return

    # Move the cursor back to the start to overwrite the prompt
    clearInput 40

    format=${1}
    range=${2}
    terminator=${3}
    echo -n -e "${format}[${range}]${terminator}\E[0m "
}

alertOnSearchComplete() {
    while [ -f $status -a "`cat $status`" != "COMPLETED" ]; do
        : # Do nothing until search is complete
    done

    displayDefaultPrompt "\E[35m" # Goes purple on complete to coax a refresh
}

waitForInput() {
    cin=""
    in=""
    clean=0
    multiSelRange=""
    updatePrompt=1

    # Loop and listen for input
    while true; do
        echo "inputMode = $inputMode" >> $log

        if [ $clean -gt 0 ]; then
            clearInput ${#in}
            in=""
            clean=0
        fi

        if [ $updatePrompt -gt 0 ]; then
            case $inputMode in
            DEFAULT)
                if [ -f $status -a "`cat $status`" != "COMPLETED" ]; then
                    displayDefaultPrompt "\E[1m\E[34m" # Display as bright blue to show not complete
                    # alertOnSearchComplete &
                else
                    displayDefaultPrompt
                fi
            ;;
            MULTI_SELECT)
                displayPrompt "" "${multiSelRange}, ." "#"
                ;;
            esac
            updatePrompt=0
        fi

        # Parse out value read in
        read -n1 cin

        case $cin in
        r) clearInput 1
            echo ""
            return 1
            ;; # Refresh the results list
        q) echo ""
            return 0
            ;; # Quit
        esac
        case $inputMode in
        DEFAULT)

            case $cin in
            [0-9]) in="${in}${cin}";;
            m) clearInput 1
                inputMode="MULTI_SELECT"
                updatePrompt=1
                clean=1
                ;; # Multiple, specific selection
            !) clearInput 1
                echo "Execute command on selected files" >> $log
                ;;

            \*) if [ ${#numResults} -le $MAX_RESULTS_TO_OPEN ]; then
                    clearInput 1
                    openMultipleResults
                fi
                ;; # Open all results
            *) clearInput 1;; # Ignore anything else
            esac

            if [ ${#in} -eq ${#numResults} ]; then
                [ ${in} -gt 0 -a ${in} -le ${numResults} ] && openResult ${in}
                clean=1
            fi

            ;;
        MULTI_SELECT)
            case $cin in
            [0-9\-]) in="${in}${cin}";;
            ,)  clearInput 1
                multiSelRange=`echo "${multiSelRange},${in}" | sed 's/^,//'`
                updatePrompt=1
                clean=1
                ;;
            c)  clearInput 1
                multiSelRange=""
                updatePrompt=1
                clean=1
                ;;
            \*) clearInput 1
                openMultipleResults "${multiSelRange}"
                ;;
            \.) clearInput 1
                inputMode="DEFAULT"
                multiSelRange=""
                updatePrompt=1
                clean=1
                ;;
            *) clearInput 1;; # Ignore anything else
            esac
            ;;
        esac

    done

    return 0
}

clearInput() {
    # Rep 1: Moves the cursor back # of chars
    # Rep 2: Replaces the chars with spaces
    # Rep 3: Moves the cursor back # of chars
    rep=0
    while [ $rep -lt 3 ]; do
        c=$1
        while [ $c -gt 0 ]; do
            [ $rep -eq 1 ] && echo -n " " || echo -n ""
            c=`expr $c - 1`
        done
        rep=`expr $rep + 1`
    done
}

doArAction() {
    ar=$1; shift
    action=$1; shift
    [ $# -gt 0 ] && args="$@" || args=""

    case $action in
    EXTRACT)
        case "${ar}" in
        *jar) cmd="jar -xvf";;
        *tar) cmd="tar -xvf";; # Have to deal with bzipped and bz.tar/gz.tar name
        *tgz) cmd="tar -xvzf";;
        *zip) cmd="unzip";;
        esac
        ;;
    LIST)
        case "${ar}" in
        *jar) cmd="jar -tf";;
        # *bz2|*gz|*tar|*tgz) ;;
        *tar) cmd="tar -tf";; # Have to deal with bzipped and bz.tar/gz.tar name
        *tgz) cmd="tar -tzf";;
        *zip) cmd="unzip -l";;
        esac
        ;;
    esac

    ${cmd} "${ar}" "${args}"
}

grepArchive() {
    #TODO: Don't need this header when there are no hits without replicating the search each time!
    [ `doArAction "$@" "LIST" | egrep -c ${CIOpt_grep} "${expression}"` -le 0 ] && return
    echo -e "${RESULT_TYPE_ARCHIVE}${DELIM}\E[33m${AR_ARCHIVEDELIM} ${@}\E[0m"
    doArAction "$@" "LIST" | egrep ${CIOpt_grep} "${expression}" | awk "{ print \"${RESULT_TYPE_ARCHIVE}${DELIM}${@}${DELIM}\"\$0 }"

    # hits=`doArAction "$@" "LIST" | egrep ${CIOpt_grep} "${expression}"`
    # [ `echo $hits | wc -l` -le 0 ] && return
    # echo -e "${RESULT_TYPE_ARCHIVE}${DELIM}\E[33m${AR_ARCHIVEDELIM} ${@}\E[0m"
    # echo $hits | awk "{ print \"${RESULT_TYPE_ARCHIVE}${DELIM}${@}${DELIM}\"\$0 }"
}

## Perform the search
touch $results
(
echo "SEARCHING" > $status
case $searchType in
UNIVERSAL)
    for f in `find . ! -name "." ! -name ".." -print`; do
        # Check if the filename matches
        echo $f | egrep ${CIOpt_grep} "${expression}" | awk "{ print \"${RESULT_TYPE_FILE}${DELIM}\"\$0 }"

        # Check if the file contents match
        egrep -nI ${CIOpt_grep} "${expression}" ${f} | sed "s;\\\s*;;" | awk "{ print \"${RESULT_TYPE_GREP}${DELIM}${f}${DELIM}\"\$0 }"

        # Check if archive contents list matches
        [ `echo $f | egrep -ci "(jar|tar|tgz|bz|gz|zip)$"` -gt 0 ] && grepArchive "${f}"
    done
    ;;
GREP_ALL)
    egrep -rnI ${CIOpt_grep} "${expression}" * | sed "s;\\\s*;;" |  awk "{ print \"${RESULT_TYPE_GREP}${DELIM}\"\$0 }"
    ;;
FILE_NAMES)
    find . -${CIOpt_find}name "*${expression}*" -print | awk "{ print \"${RESULT_TYPE_FILE}${DELIM}\"\$0 }"
    ;;
AR_CONTENTS)
    for a in `find . -print | egrep -i "(jar|tar|tgz|bz|gz|zip)$"`; do
        grepArchive "${a}"
    done
    ;;
esac 2>/dev/null > $results
echo "COMPLETED" > $status
) &
children="$children $!"

# Output message as search occurs
throbber_chars=("/" "-" "\\" "|")
throbber_pos=-1
srchMsg="Searching  |"
echo -n $srchMsg
while [ ! -f "$status" -o "`cat $status`" != "COMPLETED" ]; do
    if [ `cat $results | wc -l` -gt 0 ]; then # Output results as soon as we have any
        sleep 0.125
        break;
    elif [ ! -f "$status" -o "`cat $status`" == "SEARCHING" ]; then
        throbber_pos=`expr $(expr $throbber_pos + 1) % 3`
        echo -n "${throbber_chars[$throbber_pos]}"
        sleep 0.0625
    fi
done
clearInput ${#srchMsg}

## If there is only one result, display it
numResults=`cat $results | wc -l`
if [ $numResults -le 1 -a -f $status -a "`cat $status`" == "COMPLETED" ]; then
    if [ $numResults -gt 0 -a "$searchType" != "AR_CONTENTS" ] ; then
        set -o noglob
        echo "Opening: "`sed -n -e '1p' $results | sed -e "s/^[a-z]${DELIM}//"`
        set +o noglob
        openResult 1
    else
        echo "No results found."
    fi
    exit 0
fi

## Display the results and parse the commands
displayResults && waitForInput
input=$?
while [ $input -gt 0 ]; do
    case $input in
    1) displayResults ;;
    esac

    waitForInput
    input=$?
done
